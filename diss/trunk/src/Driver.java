import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.StringTokenizer;

import compiler.tools.AllErrorPrinter;
import compiler.tools.CommandLineOptions;
import compiler.tools.CommandNotFoundException;
import compiler.tools.ExeCommand;
import compiler.tools.GccParser;

/**
 * The Driver class, this is the main class for the ncc (Novice C Compiler)
 * application. It kicks everything off including both the compilers, however
 * it does not contain the main method because this in in the ncc class which 
 * takes care of the command line args and basic error handling etc. This 
 * step also allows the compiler to  be called ncc from the command line.
 * 
 * Notes: The Driver class should be able to handle a file with any type
 * of extension, the error checking in the ncc application specifies that
 * only .c files will be passed to a Driver object when called from ncc. 
 * 
 * @author 		Richard Hill
 * @version 	0.1
 */

public class Driver 
{
	private CommandLineOptions clo;
	private String gccOutput = "";
	private File gccOutputFile;
    
	/**
     * The constructor for a Driver Object does not initialise anything, it
     * just calls its begin method and passes on the String of the file the 
     * use wishes to parse.
     * 
     * @param clo			The structure containing all the command line 
     * 						options.
     */
	public Driver(CommandLineOptions clo)
    {
    	this.clo = clo;
    	if(clo.oDest.equals("a.out")){
    		//leave the -o flag in GCC out of the command string
    	}
    	else{
    		//construct the options string to pass to GCC 
        	gccOutput = "-o " + clo.oDest + " ";
    	}
    	begin(clo.fName);
    }
    
    /**
     * Begin the processing.
     * 
     * @param file2Parse	The file to Parse.
     */
    public void begin(String file2Parse)
    {
    	/* 
    	 * The first job to do when entering this program is to test 
    	 * to see if GCC is installed? 
    	 * 
    	 * Should implement a command line flag which would be tested here
         * and tells the program to not check for GCC as we know it's not
         * present,  it should be noted in "--help" that when this option 
         * is run there will obviously be no output other than errors 
         * (basically no program will be created as GCC is not here to do it).
         */
        if(testEnvironmentForGCC()){
        	/* 
        	 * GCC found OK!
        	 * Now compile the input file with GCC using a standard set
        	 * command line flags.
        	 */
        	compileWithGCC(file2Parse);
        	
        	//Once compilation has taken place check the output file...
        	try {
        		FileReader read = new FileReader(gccOutputFile);
				BufferedReader reader = new BufferedReader(read);
				//Test to see whether the file is empty?
				if(reader.read()==-1){
					/*
					 * The file is empty! Therefore the file compiled perfectly
					 * under GCC hence there is no point running NCC! 
					 * Just need to tidy up and tell the user their output file
					 * e.g. a.out was successfully created in the same 
					 * directory as the source file. 
					 */
					System.out.println("ncc: Output: '" + clo.oDest + "' was successfully generated!");
				}
				else{
					/*
					 * Some kind of output was generated by GCC so we need to
					 * see what it was and determine whether to run NCC or not.
					 * 
					 * The first check is to make sure gcc could find the file 
					 * the user wanted to compile, if it could not then we should
					 * relay this information and exit the entire application 
					 * without running NCC as there is no point (no file).
					 */
					String nif;
					if((nif = reader.readLine()).contains("No such file or directory")){
						//GCC could not file the input file, halt execution.
						System.out.println("g" + nif); //Replace the g we read earlier.
						while((nif = reader.readLine()) != null){
							System.out.println(nif);
						}
					}
					else{ 
						//Parse gcc output
						GccParser gp = new GccParser(gccOutputFile);
						
						//Create a new Novice C Compiler
						NoviceCCompiler ncc = new NoviceCCompiler(clo);
						
						//Deal with all the errors, printing etc.
						new AllErrorPrinter(gp.getGccErrors(), ncc.getNccErrors(), clo);
						
						/*
						 * Check the file line by line for any occurrence of the 
						 * word 'error'. If 'error' does not exist in the file then
						 * all GCC has output is warnings so we can tell the user 
						 * their output file was generated successfully. 
						 * 
						 * This section of code also prints GCC's output if the 
						 * flag is set to true.
						 */
						if(clo.forceGcc || clo.verbose){
							System.out.println("\nVerbatim GCC Output:");
						}
						FileReader read2 = new FileReader(gccOutputFile);
						BufferedReader reader2 = new BufferedReader(read2);
						String input;
						boolean progGenerated = true;
						while( (input = reader2.readLine()) != null){
							//Print GCC output is required
							if(clo.forceGcc || clo.verbose){
								System.out.println(input);
							}
							//if any input 
							if( (input.contains("error")) || (input.contains("exit")) ){
								progGenerated = false;
							}
						}
						read2.close();
						reader2.close();
						//Print program successfully generated message
						if(progGenerated){
							System.out.println();
							if(gccOutput.equals("")){
								System.out.println("ncc: Output: 'a.out' was successfully generated!");
							}
							else{
								System.out.println("ncc: Output: '" + gccOutput.substring(3, gccOutput.length()-1) + "' was successfully generated!");
							}
						}
					}
				}
				reader.close();
				read.close();
			}
        	catch(FileNotFoundException e0){
				System.out.println("File Not Found: " + e0.getMessage());
			}
        	catch(IOException e1){
				System.out.println("Read Error: " + e1.getMessage());
			}
        }
        else{
        	//GCC was not found or an error occurred during detection 
        	System.out.println("Cannot continue - program exiting!");
    		System.exit(1);
        }
    }

	/**
     * This method tests the environment to see if GCC is installed, if it 
     * is it prints the version information for the version installed and 
     * returns true, if it is not it catches the command error and prints 
     * the problem to the screen returning false. 
     * 
     * @return	A boolean, true if GCC was detected, false if it was not or
     * 			a error occurred.
     */
    private boolean testEnvironmentForGCC()
    {
    	try{
    		ExeCommand gccVer = new ExeCommand("gcc -v", "err");
    		File gccVerFile = gccVer.go("gcc.ver");
    		//Request that this temp file is deleted when the JVM exits
    		gccVerFile.deleteOnExit();
    		try{
                FileReader fileR = new FileReader(gccVerFile);
                BufferedReader reader = new BufferedReader(fileR);
            
                String textInput = null;
                while((textInput = reader.readLine()) != null){
                	StringTokenizer st = new StringTokenizer(textInput.trim().toLowerCase(), " ");
    				if(st.nextToken().equals("gcc")){
    					//Print that line (usually last line of output)
    					//System.out.println(textInput);
    					if(!textInput.contains("version 3.4")){
    						//Illegal version of gcc - cannot run
    						throw new CommandNotFoundException("GCC Version 3.4.* not detected!");
    					}
    				}
                }
                reader.close();
                fileR.close();
            }
            catch(IOException e){
                System.out.println("IOException reading from file: " + e.getMessage());
            }
    	}
    	catch(IllegalArgumentException e1){
    		System.out.println(e1.getMessage());
    		return false;
    	}
    	catch(CommandNotFoundException e2){
    		System.out.println("Testing for GCC: " + e2.getMessage());
    		//Execution must not continue
    		return false;
    	}
    	return true;
	}
    
    /**
     * This method compiles the users file using GCC, storing the output in
     * the global gccOutputFile file. This file will eventually be deleted on
     * exit of the virtual machine however for debugging purposes it will 
     * persist for the time being called gcc.out on the local drive.
     * 
     * @param f		The input file name that will be compiled.
     */
    private void compileWithGCC(String f)
    {
    	String compileString = "gcc -Wall " + gccOutput + f;
		//System.out.println(compileString);
		try{
			ExeCommand gccVer = new ExeCommand(compileString, "err");
			gccOutputFile = gccVer.go("gcc.out");
			gccOutputFile.deleteOnExit();
		}
		catch(IllegalArgumentException e1){
    		System.out.println(e1.getMessage());
    	}
    	catch(CommandNotFoundException e2){
    		System.out.println("Executing GCC: '" + compileString + "': " + e2.getMessage());
    	}
	}
}
