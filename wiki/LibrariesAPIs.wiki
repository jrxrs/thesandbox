#summary A selection of Java Libraries and APIs I either use or should use...

<wiki:toc max_depth="2" />

= Build & Dependency Management =

 * [http://ant.apache.org/ Ant]
 * [http://ant.apache.org/ivy/ Ivy]
 * [http://maven.apache.org/ Maven]

= Caching =

 * [http://ehcache.org/ Ehcache]
 * !GemFire Cache
!GemFire is a Java based cache  tutorial [http://community.gemstone.com/display/gemfire/GemFire+Tutorial here]. !GemFire is a distributed cache in which each distributed peer is connected to all other peers. A more comprehensive overview can be found [http://ofps.oreilly.com/titles/9781449323950/id2325011_09-gemfire.html here]. Under the !GemFire Client/Server architecture each !GemFire peer becomes a server which also listens to connections from !GemFire clients on a separate port. A !GemFire client only connects to a limited number of these cache servers (which it discovers via a locator) but because all the !GemFire peers/servers are linked to each other the client has access to the entire data grid.

= Databases =

 * [http://hsqldb.org/ HSQLDB]

= Date/Time =

 * [http://joda-time.sourceforge.net/ JodaTime]

== Job Scheduling ==

 * [http://supportconnectw.ca.com/public/autosys/infodocs/autosys_cheatsheet.asp AutoSys]
 * [http://www.quartz-scheduler.org/ Quartz]

= Enterprise Integration =

== Camel ==

[http://camel.apache.org/ Camel]<br>
For a list of all the EIPs that Camel supports, see [http://camel.apache.org/enterprise-integration-patterns.html here].

=== Components ===

[http://camel.apache.org/jms.html JMS Component for Camel]

= The FIX Protocol =

The *F* inancial *I* nformation E *x* change Protocol.

== QuickFixJ ==

http://www.quickfixj.org/

= Static Analysis =

 * [http://www.sonarsource.org/ Sonar]

=== Tools & References ===

 * [http://www.btobits.com/fixopaedia/index.html B2Bits]
 * [http://www.critchley.biz/js/FIXProtocol.html FIX Protocol Translator]
 * [http://www.fixionary.com/ Fixionary]
 * [http://www.fixprotocol.org/specifications/fix4.4fiximate/index.html Fiximate for FIX 4.4]

= JSON =

 * [http://jackson.codehaus.org/] a [http://www.json.org/ JSON] Processor

= Middleware =

== JMS ==

 * [http://activemq.apache.org/ Apache ActiveMQ]
 * [http://www.tibco.co.uk/products/automation/messaging/enterprise-messaging/enterprise-message-service/default.jsp Tibco EMS]
 * [http://www-01.ibm.com/software/integration/wmq/ IBM WebSphere MQ]

=== Tooling ===

 * [http://www.hermesjms.com/confluence/display/HJMS/Home HermesJMS]

== Tibco ==

 * [http://www.tibco.co.uk/products/automation/messaging/enterprise-messaging/enterprise-message-service/default.jsp Tibco EMS]
 * [http://www.tibco.co.uk/products/automation/messaging/low-latency/rendezvous/default.jsp Tibco Rendezvous]

= Open JDK 7 for OS X =

[http://code.google.com/p/openjdk-osx-build/ openjdk-osx-build]

= Object Relational Mapping (ORM) =

 * [http://www.hibernate.org/ Hibernate]
 * [http://en.wikipedia.org/wiki/List_of_object-relational_mapping_software#Java List of Alternatives]

= Testing =

== Mocking ==

 * [http://code.google.com/p/mockito/ Mockito] - Intro [http://gojko.net/2009/10/23/mockito-in-six-easy-examples/ 1], [http://refcardz.dzone.com/refcardz/mockito 2]
 * [http://code.google.com/p/powermock/ PowerMock] - Used to [http://java.dzone.com/articles/using-powermock-mock-static Mock Statics] and [http://powermock.googlecode.com/files/PowerMockAtOredev.pdf Mock the un-testable] with it's [http://metlos.wordpress.com/2012/09/14/the-dark-powers-of-powermock/ Dark Powers]

== Test/Code Coverage ==

 * [http://www.atlassian.com/software/clover/overview Clover] - Java Code Coverage
 * [http://mojo.codehaus.org/cobertura-maven-plugin/index.html Cobertura] - via the Mojo plugin for Maven

= XA =

*Note:* The whole point of XA is that transactions are global (as opposed to local) which means you can tie actions/events together to make everything atomic. So essentially _global_ transactions enable you to work with multiple transactional resources (e.g. relational databases and message queues) at the same time. A _local_ transaction on the other hand is resource specific, e.g. just a JMS broker or a database.

The Java Transaction API ([http://en.wikipedia.org/wiki/Java_Transaction_API JTA]) is JavaEE's implementation of the [http://en.wikipedia.org/wiki/X/Open_XA XA] standard protocol. JTA is part of the JavaEE specification, which means that any JavaEE-compliant application server must provide JTA support (some lightweight alternatives like Apache Tomcat do not provide it). Using JTA outside a JAVA EE server takes some work to set up because you have to find and use a JTA transaction manager, such as one of these:

 * [http://www.atomikos.com/ Atomikos]
 * [http://jotm.ow2.org/xwiki/bin/view/Main/WebHome JOTM]
 * [http://www.bitronix.be Bitronix]

== Transaction Propagation ==

Transaction propagation means that if you have two methods which are both transactional and one calls the other, then method being called can simply use use the existing transaction from the first method. Propagation is defined simply as the spreading of something. [http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/transaction.html This] page can help.