#summary Notes on Polyglot Programming

<wiki:toc max_depth="3"/>

= Languages =

== Classifications ==

=== Static vs. Dynamic ===

   In languages with *dynamic* typing, a variable can contain different types at different times, where as in *static* languages variables are bound to a specific type which cannot change during its' lifetime. The key point is that dynamic typing keeps track of information about what sort of values the variables contain (for example, a number or a string), and static typing keeps track of type information about the variables.

=== Imperative vs. Functional ===

   An *imperative* language (Java being a classic example) can be thought of as languages that model the running state of a program as mutable data and issue a list of instructions that transform that running state. Program state is thus the concept that has centre stage in imperative languages. Imperative languages can be subdivided into procedural languages (where code-operates-on-data, e.g. BASIC & FORTRAN) and Object Orientated languages where data and code (methods) are bundled into objects. *Functional* languages, on the other hand, take the view that computation itself is the most important concept. Functions operate on values, as in procedural languages, but instead of altering their inputs, functions are seen as acting like mathematical functions and return new values.

=== Compiled vs. Interpreted ===

   An *interpreted* language is one in which each step of the source code is executed as is, rather than the entire program being transformed to machine code before execution begins. This contrasts with a *compiled* language, which is one that uses a compiler to convert the human-readable source code into a binary form as an initial task.

When it comes to Java the compilation phase to byte-code means that Java has features of both.

== Programming Layers ==

For the polyglot programmer, languages fall roughly into three programming layers: *stable*, *dynamic*, and *domain-specific*. Languages such as Java and Scala are best used for the stable layer of software development, whereas others, such as Groovy and Clojure, are more suited to tasks in the dynamic or domain-specific realms.

|| *Name* || *Example problem domains* ||
|| Domain-specific || Build, continuous integration, continuous deployment ||
||  || Dev-ops ||
||  || Enterprise Integration Pattern modelling ||
||  || Business rules modelling ||
|| Dynamic || Rapid web development ||
||  || Prototyping ||
||  || Interactive administrative and user consoles ||
||  || Scripting ||
||  || Tests (such as for test- and behaviour-driven development) ||
|| Stable || Concurrent code ||
||  || Application containers ||
||  || Core business functionality ||

== Groovy ==

== Scala ==

== Clojure ==

= Resources =

[http://www.java7developer.com/ The Well Grounded Java Developer] 