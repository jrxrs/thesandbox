#summary A selection of useful resources for various Programming Languages.

<wiki:toc max_depth="3" />

= To Do =

 # A section about Databases

= Java =

 * [http://www.oracle.com/technetwork/java/api-141528.html Java API Specifications]
 * [http://www.oracle.com/technetwork/java/index-141834.html Oracle's FAQ for all Java topics].

== The Absolute Basics ==

These take the form of quick fire questions with short descriptive answers.

 # *What is a class?*<br>A class is a blueprint, or prototype, that defines the variables and the methods common to all objects of a certain kind.<br>
 # *What is a object?*<br>An object is a programming unit, which defines behaviour and state.<br>
 # *What is a method?*<br>Encapsulation of a functionality which can be called to perform specific tasks.<br>
 # *What are the different types of modifiers?*<br>There are access modifiers and there are other identifiers. Access modifiers are `public`, `protected` and `private` (if no access modifier is specified then package level (or friendly) access is granted). Other are `final`, `static`, `volatile`, `transient`. 
 # *What is a wrapper class?*<br>They are classes that wrap a primitive data type so it can be used as a first class object.
 # *What is a static variable and static method? What’s the difference between two?*<br>The modifier static can be used with a variable and method. When declared as static variable, there is only one variable no matter how many instances are created, this variable is initialized when the class is loaded and stored in the `Class` object. Static methods do not need a class to be instantiated to be called, also a non static method cannot be called from static method. 
 # *What is garbage collection?*<br>Garbage Collection is a thread that runs to reclaim the memory by destroying the objects that cannot be referenced anymore. Also see the [#Garbage_Collection Garbage Collection] section below.
 # *What is an abstract class?*An abstract class is a class that cannot be instantiated directly and therefore needs to be extended and its methods implemented, a class has to be declared abstract if it has one or more abstract methods. 
 # *What is meant by a final class, methods and variables?*<br>When declared `final` a class cannot be extended (by a sub-class). Similarly when a method is declared `final` it cannot be overridden by a method belonging to a sub-class. When a primitive variable is declared `final` its value cannot be changed...If the variable is a reference to an object then it will always refer to the same object, internal attributes of the object can be changed.
 # *What is an interface?*<br>An interface is a contract that can be implemented by a class, it contains method signatures that must be implemented. 
 # *What is method overloading?*<br>Overloading is declaring multiple methods with the same name, but with a different argument list. 
 # *What is method overriding?*<br>When a method is overridden it means that a method exists in a sub-class which has the same (method signature) name and identical arguments used by the original method in the parent class. The overriding method can still call the parent method using the `super` keyword but will most likely provide some alternative behaviour. Methods may be overridden to be more `public`, not more `private`.
 # *What is casting?*<br>Conversion of one object or primitive type to another.
 # *What is the difference between `final`, `finally` and `finalize`?*<br>The modifier `final` is used on variables, methods and classes to specify certain behaviour explained above. The `finally` keyword is used as one of the blocks of code in try-catch scenarios, it is used to hold code that needs to be executed whether or not the exception occurs in the try catch block (for example to release locks or close resources, although Java SE 7 allows for this with the try with resources block). Java provides a method called `finalize()` that can be defined in the class. When the garbage collector is ready to release the storage for your object, it will first call `finalize()`, and only on the next garbage-collection pass will it reclaim the objects memory. So `finalize()`, gives you the ability to perform some important clean up at the time of garbage collection. *This use of `finalize()`, however, is not recommended, since there is no guarantee as to when, or even if, this method will be run.*
 # *What are packages?*<br>A package is a collection of related classes and interfaces providing access protection and namespace management. Packages help programmers achieve encapsulation. 
 # *What is a super class and how can you call a super class?*<br>When a class is extended that is derived from another class a relationship is created, the parent class is referred to as the super class by the derived class that is the child or sub class. The derived class can make a call to the super class using the keyword `super`. If used in the constructor of the derived class it has to be the first statement. 
 # *What is meant by a Thread?*<br>A thread is defined as an instantiated parallel process of a given program. 
 # *What is multi-threading?*<br>Multi-threading as the name suggest is the scenario where more than one threads are running. 
 # *What are two ways of creating a thread? Which is the best way and why?*<br>Two ways of creating threads are, either to extend the `java.lang.Thread` class and implement/override the `run()` method or a different class can be created which implements the `Runnable` interface, and the then implement the `run()` method. The latter is most commonly used due to the Java restriction of single implementation inheritance. Implementation of the Runnable interface solves this problem, if additional implementation inheritance (i.e. extending another class) is required.
 # *What is deadlock?*<br>Deadlock is a situation when two threads are waiting on each other to release a resource. Each thread waiting for a resource which is held by the other waiting thread. In Java, this resource is usually the object lock obtained by the `synchronized` keyword. 
 # *What are the three types of priority?*<br>`MAX_PRIORITY` which is `10`, `MIN_PRIORITY` which is `1` & `NORM_PRIORITY` which is `5`. Some concurrency texts do not recommend altering thread priorities as it can lead to starvation (where a thread never progresses).
 # *What is the use of the `synchronized` keyword?*<br>Every object has a lock, when a `synchronized` keyword is used on a piece of code the lock must be obtained by the thread first to execute that code, other threads will not be allowed to execute that piece of code until this lock is released. See [http://code.google.com/p/thesandbox/wiki/EgMessageQueue here] for code examples.
 # *What are the methods in the `Object` class?*<br>The [http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html Object] class has 11 methods, they are:
 * `clone()`
 * `equals(Object o)`
 * `hashCode()`
 * `finalize()`
 * `notify()`
 * `notifyAll()`
 * `wait()`
 * `wait(long timeout)`
 * `wait(long timeout, int nano)`
 * `toString()`
 * `getClass()`
 # *If you override `equals()` what else should you do?*<br>You should also override the `hashCode()` method in order to ensure conformation with the contract in the `Object` class, specifially that if `equals(Object)` is true for two objects then calling `hashCode()` on the same two objects must result in the same integer result. See [http://www.ibm.com/developerworks/java/library/j-jtp05273/index.html here] for some basic examples of how to write simple `equals()` and `hashCode()` methods.
 # *Explain how `wait()` & `notify()` are used?*<br>`wait()` and `notify()` belong to the `Object` class and are used in conjunction with the monitor (lock) of the object in question. A thread can obtain the monitor of an object in one of three ways:
 * By executing a synchronized instance method of that object.
 * By executing the body of a `synchronized` statement that synchronizes on the object.
 * For objects of type `Class`, by executing a synchronized static method of that class.
A thread may only call `wait()` or `notify()` on an object for which it owns the monitor, if such a thread were to call `wait()` it must release the monitor while it waits to be notified, once it is notified it must re-obtain the same monitor before continuing. Conditions are usually used to decide when to wait and actions are usually performed before notifying. See EgMessageQueue for an example.

== P.I.E. - The Pillars of Object Orientation ==

=== Polymorphism ===

[http://en.wikipedia.org/wiki/Polymorphism_in_object-oriented_programming Wikipedia: Polymorphism]

  * Is the ability of methods to behave differently, based on the object calling it

In object-oriented programming, polymorphism refers to a programming language’s ability to process objects differently depending on their data type or class. More specifically, it is the ability to redefine methods for derived [sub-] classes. For example, given a base class shape, polymorphism enables the programmer to define different area methods for any number of derived classes, such as circles, rectangles and triangles. No matter what shape an object is, applying the area method to it will return the correct results. Polymorphism is considered to be a requirement of any true object-oriented programming language.

=== Inheritance ===

[http://en.wikipedia.org/wiki/Inheritance_(computer_science) Wikipedia: Inheritance]

  * In simple words, Inheritance is way to define new a class, using classes which have already been defined

Inheritance (is a) vs. Composition (has a)

*Inheritance* is uni-directional. For example _House_ *is a* _Building_, but _Building_ is not a _House_. *Inheritance* uses the *extends* keyword. *Composition* on the other hand is used when _House_ *has a* _Bathroom_. Inheritance should not be used just to facilitate code reuse, if there is no *is a* relationship then use composition for code reuse.

Inheritance in object oriented programming means that a class of objects can inherit properties and methods from another (parent) class of objects.

*NOTE* In Java multiple inheritance of classes is not allowed, however a sub-interface can extend multiple interfaces, [http://en.wikipedia.org/wiki/Interface_%28Java%29#Subinterfaces example].

=== Encapsulation ===

[http://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming) Wikipedia: Encapsulation]

  * With Encapsulation you can hide (restrict access) to critical data members in your code , which improves security
  * Encapsulation combines data and actions together (just like a capsule)

Encapsulation is the term given to the process of hiding the implementation details of the object. Once an object is encapsulated, its implementation details are not immediately accessible any more. Instead they are packaged and are only indirectly accessible via the interface of the object. When used properly encapsulation allows us to very easily change the implementation of a class without burdening those who use it (provided we maintain a consistent interface for interaction with our class).

==== Data Abstraction ====

[http://wiki.answers.com/Q/What_is_data_abstraction_in_java Data Abstraction in Java]

  * Abstraction in the process of selecting important data sets for an Object in your software , and leaving out the insignificant ones.
  * Once you have modelled your object using Abstraction , the same set of data could be used in different applications.

=== SOLID Principles ===

Bob Martin describe five SOLID principles for good object-oriented design in his article [http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod The Principles of OOD]. These simple principles aim to jog our memories each time we begin designing, writing or refactoring code:

|| *Principle* || *Description* ||
|| *_S_*ingle responsibility principle (SRP) || Each object should do one thing, and one thing only. _So a class should have one, and only one, reason to change._ ||
|| *_O_*pen/closed principle (OCP) || Objects should be extensible but not modifiable. _So you should be able to extend a classes behaviour, without modifying it._ ||
|| *_L_*iskov substitution principle (LSP) || Objects should be replaceable by their subtypes. ||
|| *_I_*nterface segregation principle (ISP) || Small specific interfaces are better. _So make fine grained interfaces that are client specific._ ||
|| *_D_*ependency inversion principle (DIP) || Don’t depend on concrete implementations. _So depend on abstractions, not on concretions._ ||

== Modifiers ==

According to the suggestions of the Java Language Specification, 8.1.1, 8.3.1 and 8.4.3, the correct order of modifiers is:

 # `public`
 # `protected`
 # `private`
 # `abstract`
 # `static`
 # `final`
 # `transient`
 # `volatile`
 # `synchronized`
 # `native`
 # `strictfp`

== Introspection (Annotations/generics/etc.) ==

[http://stackoverflow.com/questions/2044446/java-introspection-and-reflection Reflection vs. Introspection]

Links for working with Annotations:
 * [http://stackoverflow.com/questions/1004022/java-generic-class-determine-type Determining the Type of generic implementations]
 * [http://stackoverflow.com/questions/6593597/java-seek-a-method-with-specific-annotation-and-its-annotation-element Identifying methods with a specific Annotation]
 * [http://stackoverflow.com/questions/4296910/is-it-possible-to-read-the-value-of-a-annotation-in-java Reading the value of Annotations]

== Autoboxing ==

Autoboxing is available as of Java 1.5.0 and introduces the automated handling of primitive Java type to their equivalent Wrapper class. [http://java.sun.com/j2se/1.5.0/docs/guide/language/autoboxing.html Java 1.5.0 Language Guide]

== Imports & Performance ==

Did some research and it seems that conventional wisdom suggests that using imports with the wild card character, of the form:
{{{
import javax.swing.*;
}}}
does not impact runtime performance. There is however a valid case for specifying exactly the classes you wish to import as detailed in [http://www.javafaq.nu/java-article914.html this article].

== Mutable & Immutable Objects ==

Item 15 of Effective Java (2^nd^ Ed.) explains the concept of an Immutable object (an object which cannot be mutated) very nicely, the summary is as follows:

An immutable class is simply a class whose instances cannot be modified. All of the information contained in each instance is provided when it is created and is fixed for the lifetime of the object. Examples include `String`, the boxed primitive classes, `BigInteger` & `BigDecimal`. The 5 rules for achieving immutability are:

 # Don't provide any methods (mutators) that modify the object's state.
 # Ensure that the class cannot be extended.
 # Make all fields final.
 # Make all fields private.
 # Ensure exclusive access to any mutable components.

[http://www.javaranch.com/journal/2003/04/immutable.htm Java Ranch - Mutable and Immutable Objects]

== Generics ==

[http://onjava.com/onjava/excerpt/javaian5_chap04/index1.html Writing Generic Types & Methods]

== Enums ==

[http://www.javapractices.com/topic/TopicAction.do?Id=1 Enums Summary from javapractices.com]

== Checked & Unchecked Exceptions ==

 * Checked exceptions in Java extend the `java.lang.Exception` class.
 * Unchecked exceptions extend the `java.lang.RuntimeException`.

[http://tutorials.jenkov.com/java-exception-handling/checked-or-unchecked-exceptions.html Java Exception Handling - Checked or Unchecked Exceptions]

== D-Zone Ref Cardz ==

[http://refcardz.dzone.com/ D-Zone Ref Cardz]

== Challenging Java Questions ==

[http://robaustin.wikidot.com/50-java-interview-questions Java Interview Questions]

== Concurrency, Threading & Lock Contention ==

http://www.vogella.com/articles/JavaConcurrency/article.html

First things first...why is it important to get multi-threading right in your application? Well, a thread is just a lightweight process which has access to your applications memory, introducing more than one thread means that those threads are now sharing access to your applications memory space which means it's crucial to ensure that, that shared memory is always left in a consistent state by each thread, ready to be read safely by the next thread, the procedures outlined below help ensure that this situation is achievable and that your application runs as desired. 

=== Java Concurrency in Practice ===

==== Using Synchronized Collections ====

If you use a `synchronized` collection from the Collections utility class you should take note of the correct iteration idiom, explained in the [http://docs.oracle.com/javase/6/docs/api/java/util/Collections.html#synchronizedCollection(java.util.Collection) Javadoc]:

It is imperative that the user manually synchronize on the returned collection when iterating over it:

{{{
  Collection c = Collections.synchronizedCollection(myCollection);
     ...
  synchronized(c) {
      Iterator i = c.iterator(); // Must be in the synchronized block
      while (i.hasNext())
         foo(i.next());
  }
}}}

Failure to follow this advice may result in non-deterministic behaviour. 

==== Summary of Part 1 ====

 * It's the mutable state, stupid.
   All concurrency issues boil down to coordinating access to mutable state. The less mutable state, the easier it is to ensure thread safety. 
 * Make fields final unless they need to be mutable. 
 * Immutable objects are automatically thread safe. 
 * Immutable objects simplify concurrent programming tremendously. They are simpler and safer, and can be shared  freely without locking or defensive copying. 
 * Encapsulation makes it practical to manage the complexity. 
   You could write a thread safe program with all data stored in global variables, but why would you want to? Encapsulating data within objects makes it easier to preserve their invariants; encapsulating synchronization within objects makes it easier to comply with their synchronization policy. 
 * Guard each mutable variable with a lock. Guard all variables in an invariant with the same lock.   
 * Hold locks for the duration of compound actions. A program that accesses a mutable variable from multiple threads without synchronization is a broken program. 
 * Don't rely on clever reasoning about why you don't need to synchronize.  
 * Include thread safety in the design processor explicitly document that your class is not thread safe.
 * Document your synchronization policy.

==== Basic facts about old school synchronization ====

 * Only objects—not primitives—can be locked.
 * Locking an array of objects doesn’t lock the individual objects, i.e. just the array is locked 
 * A `synchronized` method can be thought of as equivalent to a `synchronized (this) {...}` block that covers the entire method (but note that they're represented differently in byte-code).
 * A `static` method declared `synchronized` locks the `Class` object, because there's no instance object to lock.
 * If you need to lock a class object, consider carefully whether you need to do so explicitly, or by using getClass(), *because the behaviour of the two approaches will be different in a subclass*.
 * Synchronization in an inner class is independent of the outer class (to see why this is so, remember how inner classes are implemented).
 * `synchronized` doesn't form part of the method signature, so it can’t appear on a method declaration in an interface.
 * Unsynchronized methods don't look at or care about the state of any locks, and they can progress while synchronized methods are running.
 * Java’s locks are re-entrant. That means a thread holding a lock that encounters a synchronization point for the same lock (such as a synchronized method calling another synchronized method in the same class) will be allowed to continue.

=== Lock Contention ===

[http://www.thinkingparallel.com/2007/07/31/10-ways-to-reduce-lock-contention-in-threaded-programs/ 10 Ways to Reduce Lock Contention in Threaded Programs]

== Java's Threading Model ==

Chapter 4 of The Well Grounded Java Developer begins by discussing Java's Threading Model which is based on two fundamental concepts:

 * Shared, visible-by-default mutable state
 * Pre-emptive thread scheduling

They go on the decompose these further:

 * Objects can be easily shared between all threads within a process.
 * Objects can be changed ("mutated") by any threads that have a reference to them.
 * The thread scheduler can swap threads on and off cores at any time, more or less. 
 * Methods must be able to be swapped out while they’re running (otherwise a method with an infinite loop would steal the CPU forever). This, however, runs the risk of an unpredictable thread swap leaving a method "half-done" and an object in an inconsistent state. There is also the risk of changes made in one thread not being visible in other threads when they need to be. To mitigate these risks, we come to the last point.
 * Objects can be locked to protect vulnerable data.

== Design Principles for Concurrent Code ==

Doug Lea gives 4 main principles to keep in mind when designing and writing concurrent code; *Safety*, *Liveness*, *Performance* & *Re-usability*.

SAFETY AND CONCURRENT TYPE SAFETY<br>
Safety is about ensuring that object instances remain self-consistent regardless of any other operations that may be happening at the same time.

LIVENESS<br>
A live system is one in which every attempted activity eventually either progresses or fails.

PERFORMANCE<br>
Definitions of performance are often pretty woolly, we'll go for: performance being a measure of how much work a system can do with a given amount of resources.

REUSABILITY<br>
We should ensure that any code we write to support concurrency can be reused else where, this was the point of the `java.unit.concurrent` library. 

== Caching ==

[http://www.cacheonix.com/articles/Caching_for_Java_Applications.htm Main Reference]

Caching can help to increase application performance and scalability.

=== In a Nut Shell ===

A cache is an area of local memory that holds a copy of frequently accessed data that is otherwise expensive to get or compute. A simple caching API would consist of the a `get(Object Key)` method and a `put (Object key, Object value)` method.

A cache works as follows: An application requests data from cache using a key. If the key is not found, the application retrieves the data from a slow data source and puts it into the cache. The next request for a key is serviced from the cache.

=== Temporal and Spatial Locality ===

*Temporal Locality*<br>The concept that a resource that is referenced at one point in time will be referenced again sometime in the near future.

*Spatial Locality*<br>The concept that likelihood of referencing a resource is higher if a resource near it was just referenced.

*Note:* When implementing a cache it is vital that you do not ignore temporal or spatial locality as doing so would result in everything being cached, this approach will in fact reduce application performance making _Cache Them All_ an anti-pattern. The degradation of performance is caused by the overhead of maintaining a cache without benefiting from reduced cost of access to frequently used data.

=== Cache Eviction Policy ===

A cache eviction policy is an algorithm according to which an existing element is removed from a cache when a new element is added. The eviction policy is applied to ensure that the size of the cache does not exceed a maximum size. Least Recently Used (LRU) is one of the most popular among a number of eviction policies. LRU earned its popularity for being the best in capturing temporal and spatial locality of data access.

=== Measuring Cache Performance ===

You tend to measure the performance of a cache using the ratio of cache hits to cache misses.

=== Uses ===

Object-relational mapping (ORM) frameworks like Hibernate or data mapping (DM) frameworks such as iBatis ofen provide Level-2 caches of data stored in a database. The application only interacts with the framework and this shields it from all the caching complexities. 

== Object Relational Mapping (ORM) Frameworks ==

TODO!

== Not only SQL (NoSQL) ==

In short, NoSQL database management systems are useful when working with a huge quantity of data when the data's nature does not require a relational model (i.e. you don't guarantee the ACID principles usually associated with relational databases). The data can be structured, but NoSQL is used when what really matters is the ability to store and retrieve great quantities of data, not the relationships between the elements. Usage examples might be to store millions of key–value pairs in one or a few associative arrays or to store millions of data records.

There are numerous example of NoSQL solutions available including [http://cassandra.apache.org/ Apache Cassandra], GemFire, [http://www.mongodb.org/ MongoDB], [http://www.neo4j.org/learn Neo4j].

== Garbage Collection ==

A good introduction/overview of the basics can be found [http://www.javarevisited.blogspot.co.uk/2011/04/garbage-collection-in-java.html here] on the [http://www.javarevisited.blogspot.co.uk/ JavaRevisited Blog]. Alternatively see [http://www.oracle.com/technetwork/java/javase/tech/index-jsp-140228.html here] for all the gorey details from Oracle, particularly their [http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html GC Tuning] page.

=== Memory Leaks in Java ===

Although it might not seem obvious at first it is possible for Java code to suffer from memory leaks, Item 6 of Effective Java 2^nd^ Ed. covers this topic and defensive strategies to help avoid.

Generally speaking memory leaks in Java are due to resources (like files or connections) not being closed correctly before they are moved out of scope, this leaves them hanging around uncollected the garbage collector. The example in Item 6 addresses problems when not nulling out references in an array storing a collection of objects, while basic this is an east example to see how memory could be leaked.

== Logging ==

 * [http://logging.apache.org/log4j/1.2/ log4j]
 * [http://www.slf4j.org/ slf4j] is a logging abstraction which shields the developer from having to check is a log level is enabled before creating any, otherwise unnecessary, dynamically compiled Strings, this is explained in more detail [http://www.slf4j.org/faq.html#logging_performance here]. It stands for Simple Logging Façade for Java and allows the user to plus in which logging framework they want to use (e.g. java.util.logging, log4j and logback) at deployment time. A major benefit of slf4j is that your other libraries can use whatever logging framework they like, but the façade will result in all your logs coming out via you chosen deploy time library.

=== Declaring Loggers ===

A cautionary note when declaring loggers...
Normal practice when declaring a logger is to use something along the lines of:

{{{
private static final LOGGER = Logger.getLogger(MyClass.class);
}}}

This is handy and efficient as it means you'll only ever have one instance of the logger which all instances of the class with use. However this is not always applicable as it can result in misleading log messages if you happen to need to log in a class that will be sub-classed, if you need to do this you'll have to have a logger per instance and use a call to `getClass()` for the logger name.

{{{
private final logger = Logger.getLogger(getClass());
}}}

== Testing ==

Apparently nobody has a team of QA's dedicated to their application any more...there are these things called test cases which the developers write based on stories from the business. Below are a few frameworks for driving these tests:

==== TDD ====
The theory with Test Driven Development is that you write one test, then you code just enough to get your test to pass, then you go back and write the another test, code enough to pass that and go back to your code and attempt to refactor any commonality, testing again post refactoring.
 * [http://www.junit.org/ JUnit]
 * [http://testng.org/doc/index.html TestNG]

==== BDD ====
 * [http://fitnesse.org/FrontPage FitNesse]
 * [http://jbehave.org/ jbehave]
 * [http://www.concordion.org/ Concordion]

=== Test Doubles & Mocking ===
Test double are used to facilitate testing just the code you're actually writing rather than indirectly testing someone else's code like a third parties database implementation. Gerard Meszaros’s simple explanation of a test double is as follows:

  A Test Double (think Stunt Double) is the generic term for any kind of pretend object used in place of a real object for testing purposes.

He goes one to categorise objects into four compartments depending on the extent to which they are implemented:

|| *Type* || *Description* ||
|| Dummy || An object that is passed around but never used. Typically used to fulfil the parameter list of a method. ||
|| Stub || An object that always returns the same canned response. May also hold some dummy state. ||
|| Fake || An actual working implementation (not of production quality or configuration) that can replace the real implementation. ||
|| Mock || An object that represents a series of expectations and provides canned responses. _Also see below._ ||

==== Mocking ====
Mocking allows you to pinpoint specific functionality while testing, you might have a method to test which uses RefData for instance, instead of making that call to retrieve the ref data you can choose to mock that call out and return a constant value facilitating your expected result for the original test case. The Wikipedia entry for Mocking appears under [http://en.wikipedia.org/wiki/Mock_object Mock Object].
 * [http://code.google.com/p/mockito/ Mockito]
 * [http://code.google.com/p/powermock/ PowerMock]

A quick introduction to Mockito can be found [http://gojko.net/2009/10/23/mockito-in-six-easy-examples/ here].

== Continuous Integration (CI) ==

A section on various Continuous Integration platforms e.g. TeamCity, Jenkins (& Hudson), [https://confluence.atlassian.com/display/BAMKB/Bamboo+Knowledge+Base+Home Bamboo] etc. should go here.

== Application Containers ==

A few years ago micro-containers became very popular for Java applications as J2EE started to become the heart of most applications, mainly because it allows you to plug in common components like JDBC, JMS etc. easily.

=== Spring ===

*Spring handles the infrastructure so you can focus on your application.*

==== Spring Links ====
 * [http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/ Documentation for 3.1.x]
 * [http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/beans.html The IoC container documentation]
 * [http://www.springbyexample.org/ Spring by Example]

Spring rapidly became the default container of choice allowing you to create beans (simple pojos) and then plug one into the other gradually building up a dependency graph which Spring manages throughout the application's life-cycle ensuring nothing which is still in use in destroyed prematurely i.e. scope management which is also controllable by the user e.g. Singleton or Session.

Creating beans is usually accomplished using constructor injection or setter injection, constructor injection is usually favoured however it can introduce difficulties when circular dependencies are unavoidable (however generally we should design our way around these types of dependencies). 

The advantages of Spring are many and varied, it allows access to beans externally with JMX, it allows you to configure caching transparently and supports Aspect Oriented Programming - the idea of wrapping your core pojo with various aspects which provide some additional level of functionality with each layer e.g. security, transaction management, logging caching etc. 

== Remote Method Invocation (RMI) ==

[http://docs.oracle.com/javase/tutorial/rmi/index.html Oracle's RMI Tutorial]

The Java Remote Method Invocation (RMI) system allows an object running in one Java virtual machine to invoke methods on an object running in another Java virtual machine. RMI provides for remote communication between programs written in the Java programming language.

== What's new in Java 5? ==

These headlines have been scraped from [http://en.wikipedia.org/wiki/Java_version_history here].

 # Annotations - allowing programmers to provide metadata tags to language constructs (classes, methods, etc.)
 # Generics - allowing collections to be statically type checked at compile time and eliminating the need for most typecasts.
 # Autoboxing/unboxing - see [http://code.google.com/p/thesandbox/wiki/Resources#Autoboxing above].
 # Enumerations = i.e. the `enum` keyword
 # Varargs - The last parameter of a method can now be declared using a type name followed by three dots (e.g. `void drawtext(String... lines)`). In the calling code any number of parameters of that type can be used and they are then placed in an array to be passed to the method, or alternatively the calling code can pass an array of that type.
 # The enhanced for-each loop was added.
 # The semantics of the `volatile` keyword were changed to ensure that threads never read a volatile variable from a local cache.
 # `import static ...` was added
 # The `java.util.concurrent` package was added

== What's new in Java 6? ==

 # General upgrades and performance upticks across the Java estate, particularly for the Java core and Swing.
 # Improved garbage collection and tuning
 # `SwingWorker` is added as a standard library class

These headlines have been scraped from [http://en.wikipedia.org/wiki/Java_version_history here].

== What's new in Java 7? ==

The main source of information for this section was the Well Grounded Java Developer.

 # `String` values in `switch` statements
 # The syntax for declaring numeric literals has been changed so you can use underscore characters `_` when declaring integers e.g. `int x = 1_000_000;`, you can also declare numbers explicitly as binary strings e.g. if you wanted `y` to be 5 you could write `int y = 0b101`.
 # Exceptions handling has been tidied up which allows you to catch multiple exceptions within the same catch statement.
 # You can also try-with-resources which aims to prevent bugs related to calling `close()` on a resource (like a `FileWriter`) incorrectly
 # Diamond syntax which allows you to infer the type of your generic objects based on their declaration.
 # Simplified varagrs method invocation, this allows you to write something like:
{{{
public static <T> Collection<T> doSomething(T... entries) {
    ...
}
}}}
  which used to case a problem because behind the scenes the compiler would create an array of whatever type you passed in as T, however if it was something like `HashMap<String, String>` you'd get a warning about type safety, this is no longer reported to the programmer using `doSomething(T... entries)` but instead to the writer of the method.

A summary of these features in code can be found [https://code.google.com/p/thesandbox/wiki/CodeExamples?ts=1350752358&updated=CodeExamples#New_Java_Features_Outline here].

There is also a change to Java's sorting algorithm in Java 7, where they will start to use Timsort.

== What about Java 8? ==

 # Lambda Expression? Closures... this is to do with [http://en.wikipedia.org/wiki/Anonymous_function anonymous functions]
 # Additional language features from project coin (Java SE 7)
 # A new Time and Date API

----

= Libraries & APIs =

http://code.google.com/p/thesandbox/wiki/LibrariesAPIs

----

= General Programming Terminology =

== Syntactic Sugar ==

  A phrase that's sometimes used to describe a language feature is "syntactic sugar". This means that the syntax form is redundant—it already exists in the language—but the syntactic sugar form is provided because it's easier for humans to work with.<br>
  As a rule of thumb, a feature referred to as syntactic sugar is removed from the compiler’s representation of the program early on in the compilation process—it's said to have been "desugared" into the basic representation of the same feature.<br>
  This makes syntactic sugar changes to a language easier to implement because they usually involve a relatively small amount of work, and only involve changes to the compiler (`javac` in the case of Java).

This is an excellent summary of Syntactic Sugar from the [http://www.manning.com/evans/ The Well-Grounded Java Developer] book by Ben Evans and Martijn Verburg.

----

= Interview Questions =

== General approach to Programming Problem Solving ==

 # Make sure you understand the problem.
 # Once you understand the question, try an example.
 # Focus on the algorithm you will use to solve the problem. *Resist any temptation to begin coding before you figure out the exact solution!*
 # After you’ve figured out your algorithm and how you will implement it, explain your solution to the interviewer.
 # While you code, it’s important to explain what you’re doing.
 # Ask questions when necessary.
 # After you’ve written the code for a problem, immediately verify that the code is correct by tracing through it with an example.
 # Make sure you check your code for all error and special cases, especially boundary conditions.

== Java ==

 * http://www.allapplabs.com/interview_questions/java_interview_questions.htm
 * [http://javarevisited.blogspot.co.uk/2011/09/swing-interview-questions-answers-in.html Java Swing Questions]
 * [http://java-success.blogspot.co.uk/ 400+ Java Interview Questions & Answers]
 * [http://java-interview-material.blogspot.co.uk/ Java Interview Material Blog]

== Logic ==

[http://imranontech.com/2007/01/10/why-logic-puzzles-make-good-interview-questions/ Why logic puzzles make good interview questions]

== Bit Twiddling Techniques ==

Bit twiddling crops up in interviews every so often so it's [http://graphics.stanford.edu/~seander/bithacks.html nice to know about...]<br/>
Also see the Java operators summary [http://docs.oracle.com/javase/tutorial/java/nutsandbolts/opsummary.html page].

== My Questions ==

 * Which application is the role for? Where does that fit within the business?
 * What are the main challenges faced by the application/team at the moment?
 * Are there any big projects or changes on the horizon for the firm?
 * What are the long term opportunities with the company?
 * How is career development managed? Are there regular training opportunities?
 * What skills and attributes are most needed to progress within the team / company?
 * Where does the company have offices? Where are the headquarters? What activities take place in each office?
 * Please could I have your business card?

== Things I've been asked ==

 * What is a [#Code_Reviews Code Review]?
 * What is my favourite programming language?
 * What is Inversion of Control and why is it useful?
 * Design a noughts and crosses board game? How would your design need to be changed to allow connect four to be played instead?
 * Design the Oyster card system for the London Underground?
 * Can you write code in Java or C++ to find the power set of a given set. For example if S={a,b} the power set is P={{},{a},{b},{a,b}}.
 * What is you favourite feature of Java? What does it do particularly well?
 * What would you change about Java given the chance.
 * [http://stackoverflow.com/questions/1801549/reverse-a-singly-linked-list How would you reverse a singly linked list?]
 * How could you implement a simple spin lock in Java using an Atomic Integer?

== The Systems I've Worked On ==

*See the Dropbox document, My Systems.docx*

----

= Java EE =

[http://docs.oracle.com/javaee/6/tutorial/doc/docinfo.html Jave EE 6 Tutorial]

----

= Web Services =

Java Web Services can be thought of as an API on the network. The API itself is defined using the Web Services Description Language (WSDL), specifying what operations you can call on a web service and what the input and output types are, among other things. Messages are typically XML, formatted to comply with the Simple Object Access Protocol (SOAP) schema and these messages are typically sent over HTTP.

----

= Middleware =

== Tibco ==

[http://javarevisited.blogspot.co.uk/2011/05/tibco-tutorials-for-beginners.html Tibco Tutorial]

== Sonic ==

== JMS ==

The above Tibco Tutorial contains a page comparing RV & EMS...it turns out that EMS is just an implementation of JMS (Java Message Service). The JMS API supports two models:

 * Point-to-point (Queues)
 * Publish and subscribe (Topics)

You need to be quite careful when choosing when to use a JMS Topic or a JMS Queue, despite what you might think you can actually have multiple subscribers on a single Queue however the effect will not be that every subscriber gets a copy of each message, but rather a round-robin/load-balanced effect where each subscriber handles a message. Topics on the other hand deliver a copy of each message to each active subscriber, if you absolutely need guarantees that each subscriber to a topic receives a copy of a message then your best bet is to create a queue for each subscriber and then bridge between the Topic each Queue, JMS providers like EMS allow you create bridges between Topics and Queues manually, provided they are on the same Broker. If you need to bridge between brokers (inter-broker) then you need to create a (bi-directional) route between the two brokers and ensure that the destinations you want to route between are both global.

The [http://en.wikipedia.org/wiki/Java_Message_Service JMS] page on Wikipedia has more information on terminology, operations and implementations.

----

= XML =

[http://www.w3schools.com/xml/default.asp eXtensible Markup Language]

== SAX & DOM ==

SAX - Event Driven, stack based parsing, akin to shift-reduce mechanism employed by bottom-up parsers. [http://en.wikipedia.org/wiki/Simple_API_for_XML Wikipedia]

DOM - Tree Walking [http://en.wikipedia.org/wiki/Document_Object_Model Wikipedia]

[http://onjava.com/onjava/2002/06/26/xml.html SAX & DOM, the Basics]

[http://www.informit.com/library/library.aspx?b=STY_XML_21days Teach Yourself XML in 21 Days]

----

= JSON =

[http://www.json.org/ JSON] stands for *J* ava *S* cript *O* bject *N* otation and was designed to be a lightweight data exchange format which is easy for humans to read. JSON is an excellent way to serialise objcets in a simple manner.

Codehaus's [http://jackson.codehaus.org/ Jackson] is a very popular JSON Processor for Java.

----

= Simple Object Access Protocol (SOAP) =

[http://en.wikipedia.org/wiki/SOAP SOAP], originally defined as Simple Object Access Protocol, is a protocol specification for exchanging structured information in the implementation of Web Services in computer networks. It relies on Extensible Markup Language (XML) for its message format, and usually relies on other Application Layer protocols, most notably Hypertext Transfer Protocol (HTTP) and Simple Mail Transfer Protocol (SMTP), for message negotiation and transmission.

----

= Regular Expressions =

== General Information on RegEx ==

 * [http://www.regular-expressions.info/reference.html Reference]

== In Java ==

 * [http://docs.oracle.com/javase/tutorial/essential/regex/ RegEx Tutorial from Oracle]

----

= Complexity (Big-O) =

Big-O analysis is a form of run-time analysis that measures the efficiency of an algorithm in terms of the time it takes for the algorithm to run as a function of the input size. It's not a formal benchmark, just a simple way to classify algorithms by relative efficiency.

[http://pages.cs.wisc.edu/~vernon/cs367/notes/3.COMPLEXITY.html Complexity & Big-O Notation]
[http://stackoverflow.com/questions/2307283/what-does-olog-n-mean-exactly Good Explanation of O(log n) from Stackoverflow]

----

= Maths =

[http://oakroadsystems.com/math/loglaws.htm Logarithms]

= Data Structures & Algorithms =

A good alternative to [http://en.wikipedia.org/ Wikipedia] articles on data structures and algorithms is http://www.algolist.net/ which provides examples in Java & C++ along with explanations and analysis.

[http://so-i-think-i-created-my-first-online-project.googlecode.com/files/Data%20Structures%20and%20Algorithms%20in%20Java%20Fourth%20Edition.pdf?bcsi_scan_4c5c01dba4894524=0&bcsi_scan_filename=Data%20Structures%20and%20Algorithms%20in%20Java%20Fourth%20Edition.pdf Data Structures & Algorithms in Java (4th Edition)]

----

== Data Structures ==

=== Trees ===

==== Depth ====
*Formal Definition:* Let _v_ be a node of a tree _T_. The depth of _v_ is the number of ancestors of _v_, excluding _v_ itself. If _v_ is the root, then the depth of _v_ is 0.<br>
*Informal Definition:* How deep down the tree is the node you're concerned with?

==== Height ====
*Formal Definition:* The height of a node _v_ in a tree _T_ is defined recursively:
 * If _v_ is an external node, then the height of _v_ is 0
 * Otherwise, the height of _v_ is one plus the maximum height of a child of _v_.<br>
*Informal Definition:* So basically how far is _v_ away from it's further descendant which is a leaf (external node). 

Adapted from [http://en.wikipedia.org/wiki/Red_black_tree Red-Black Tree]: Both Red-Black tree ([http://www.ece.uc.edu/~franco/C321/html/RedBlack/redblack.html demo]) and AVL trees ([http://www.strille.net/works/media_technology_projects/avl-tree_2001/ demo]) support O(log n) search, insertion, and removal. AVLs are more rigidly balanced than red–black trees, leading to slower insertion and removal but faster retrieval. This makes AVLs attractive for data structures that may be built once and loaded without reconstruction, such as language dictionaries (or program dictionaries, such as the opcodes of an assembler or interpreter).

2-4 Trees ([http://www.cs.unm.edu/~rlpm/499/ttft.html demo]) are fundamental to understanding red-black trees because the insertion and deletion operations on 2-4 trees are also equivalent to colour-flipping and rotations in red–black trees, despite this 2-4 trees are seldom used in practice. Try walking through the [http://en.wikipedia.org/wiki/2-4_tree#Example example] from wikipedia of a 2-3-4 tree insertion.

*Differentiating Red-Black Trees*

Although AVL trees and (2,4) trees have a number of nice properties, there are some dictionary applications for which they are not well suited. For instance, AVL trees may require many restructure operations (rotations) to be performed after a removal, and (2,4) trees may require many fusing or split operations to be performed after either an insertion or removal. The red-black tree data structure does not have these drawbacks, however, as it requires that only O(1) structural changes be made after an update in order to stay balanced.

In Java [http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html TreeMap] is an example of a Red-Black tree.

=== Heaps ===

The description from Wikipedia for the [http://en.wikipedia.org/wiki/Heap_%28data_structure%29 Heap] data structure is very clear on concise. Essentially, the structure is a binary tree where some form of ordering is used to determine where each node is placed, for instance if you were ordering percentages on a max-heap 100 would be at the top, 1 at the bottom. When you add a node to this type of structure you always fill the next level with empty places from the left to the right, once you add a value you compare it to it's parent and if ordering dictates that the new node should come before it's parent you swap them in the structure (and carry on until you don't need to swap or you reach the root). Similarly if you remove the root you then swap the most recently added item into the root's position and compare the new root with each of it's children, swapping with the most appropriate child e.g. the larger of the two in the case of a max-heap. Again you continue this process until you don't need to swap again or you reach a leaf.

Heaps are used in Heap Sorts to achieve worst case performance of O(n log n).

In Java the [http://docs.oracle.com/javase/6/docs/api/java/util/PriorityQueue.html Priority Queue] is an example of a min-heap.

=== Sets ===
A Set stores unique elements.

=== Maps ===
In the conventional sense of the word a Map is a data structure which maps a key to a value, each key should map to exactly one value.

==== LinkedHashMap ====
Hash table and linked list implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order). Note that insertion order is not affected if a key is re-inserted into the map. (A key k is reinserted into a map m if m.put(k, v) is invoked when m.containsKey(k) would return true immediately prior to the invocation.)

There is also an equiv. for Sets called LinkedHashSet, which could be compared to TreeSet and HashSet.

==== MultiMap ====
A multimap is a generalisation of a map or associative array abstract data type in which more than one values may be associated with and returned for a given key. Often multimap is implemented as a map wth lists or sets as the map values. Both Apache Commons Collections & Google Collections offer MultiMap implementations.

==== ConcurrentHashMap ====

Section 5.2.1 of Java Concurrency In Practice explains the internals of a ConcurrentHashMap at a high level, essentially lock striping is used to allow multiple readers to access the map concurrently and writers are managed on a lock per bucket basis reducing contention across the whole collection. The author(s) note that under normal circumstances there should be little or no overhead of using a ConcurrentHashMap where a Hashtable or synchronized Map was used before, it should be much more scalable as a collection.

=== Stacks ===

=== Lists ===

=== Queues ===
A Queue is a basic Collection in Java that offers 5 additional methods for interacting with the collection in a queue fashion:
{{{
    boolean offer(E e); // inserts, if possible
    E poll();           // retrieves and removes head of queue
    E remove();         // like poll() but throws exception
    E peek();           // retrieves head without removing
    E element();        // like peek() but throws exception
}}}

==== Concurrent Linked Queue ====
 * Unbounded thread-safe Queue based on linked nodes
 * Elements ordered FIFO
 * Used when many threads share access to a queue
 * The size() method is not constant time (it have to count all elements each time)
 * can often be used as a thread-safe low-contention list

==== Priority Queue ====
 * Unbounded priority queue based on priority heap
 * Orders elements according to order specified at construction time (either natural order or via Comparable, or by Comparator)
 * Least element is at the head of the queue (this queue is not stable, thus when two elements are equals their insertion order is not maintained - you would have to provide this mechanism yourself)
 * A normal Priority Queue is not thread-safe, however a Priority Blocking Queue (see below) is.
 * If you need to see the items in the queue in reverse order (i.e. largest first) then just create a reverse comparator and use that for head building.

=== Blocking Queues ===

We also have the Blocking Queue interface which includes the `put()` and `take()` methods which block until space or elements become available (respectively). These types of queue are frequently used in Producer/Consumer scenarios.

There are various Blocking Queue implementations:
 * *!ArrayBockingQueue* - underlying container is an array
 * *!LinkedBlockingQueue* - Linked queues typically have higher throughput than array-based queues but less predictable performance in most concurrent applications.
 * *!DelayQueue* - Only delivers after some time-out has expired
 * *!PriorityBlockingQueue* - Returns by sort order, smallest elements first
 * *!SynchronousQueue* - Queues of size zero, used if you do not want asynchronicity

=== Deques ===
A Deque is a double‐ended queue that allows efficient insertion and removal from both the head and the tail. Implementations include ArrayDeque and LinkedBlockingDeque.

Just as blocking queues lend themselves to the producer-consumer pattern, deques lend themselves to a related pattern called work stealing. A producer-consumer design has one shared work queue for all consumers; in a work stealing design, every consumer has its own deque. If a consumer exhausts the work in its own deque, it can steal work from the tail of someone else's deque. Work stealing can be more scalable than a traditional producer-consumer design because workers don't contend for a shared work queue; most of the time they access only their own deque, reducing contention. When a worker has to access another's queue, it does so from the tail rather than the head, further reducing contention.

Deques are introduced in section 5.3.3 of Java Concurrency in Practice.

=== LRU Cache ===

A Least Recently Used Cache is an extension of a LinkedHashMap. Usually, the LinkedHashMap orders elements by insertion order however we can change that to access order in the constructor. See Java Specialist Masters course (slide 640).

Alternatively you can implement a cache with the LRU eviction policy with a map and a linked list. The map stores cached elements. The linked list keeps tracks of the least recently used cache elements. When a cache element is updated, it is removed from the list and added to the top of the list. The new elements are added to the top of the list as well. If the cache grows bigger than its maximum size, an element is removed from the bottom of the list and from the map. This way the least recently used elements are evicted first.

== Sorting ==

There are lots of different types of sorting algorithms, only some are covered here. A comparison of the space complexity of many of those featured can be found [http://en.wikipedia.org/wiki/Timsort#Performance here].

=== Stable vs. Unstable Sorts ===
*Stable* sorting algorithms maintain the relative order of records with equal keys.<br>
*Unstable* sorting algorithms may change the relative order of records with equal keys, but stable sorting algorithms never do so.<br>
Unstable sorting algorithms can be specially implemented to be stable. One way of doing this is to artificially extend the key comparison, so that comparisons between two objects with otherwise equal keys are decided using the order of the entries in the original data order as a tie-breaker. Remembering this order, however, often involves an additional computational cost.

=== Selection Sort - O(n^2^) ===
*Basic Idea*: Ascend the unsorted array until the find the smallest value in the list, swap that value with the value in the first spot, then search adjust the position you are attempting to fill and search again for the next smallest etc. continuing until you reach the end and everything is sorted.

Selection sort is sometimes useful for small data sets where memory is limited.
Worst Case Performance: O(n^2^)
Best Case Performance: O(n^2^)
Average Case Performance: O(n^2^)

=== Insertion Sort - O(n^2^) ===
*Basic Idea*: Insertion sort is a simple sorting algorithm that is relatively efficient for small lists and mostly sorted lists, and often is used as part of more sophisticated algorithms. It works by taking elements from the list one by one and inserting them in their correct position into a new sorted list. In arrays, the new list and the remaining elements can share the array's space, but insertion is expensive, requiring shifting all following elements over by one.

Generally speaking (and despite having same worst case complexity) an Insertion Sort is expected to perform better than a Selection Sort.

Worst Case Performance: O(n^2^) comparisons, swaps
Best Case Performance: O(n) comparisons, O(1) swaps
Average Case Performance: О(n^2^) comparisons, swaps

[http://en.wikipedia.org/wiki/Insertion_sort#Comparisons_to_other_sorting_algorithms Comparisons]

=== Bubble Sort - O(n^2^) ===
*Basic Idea*: Bubble sort works by repeatedly stepping through the list to be sorted, comparing each pair of adjacent items and swapping them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted.

Worst Case Performance: O(n^2^)
Best Case Performance: O(n)
Average Case Performance: O(n^2^)

=== Quick Sort - O(n log n) (although not guaranteed) ===
*Basic Idea*: Is similar to merge sort in that is it a divide and conquer algorithm. [http://opendatastructures.org/versions/edition-0.1e/ods-java/11_1_Comparison_Based_Sorti.html#SECTION001412000000000000000 link] The basic idea is to pick a pivot value and move elements around (by swapping them) so that they fall on the correct side of the pivot value.

As the the Java Arrays API http://docs.oracle.com/javase/6/docs/api/java/util/Arrays.html#sort(int[]) Java uses a tuned quicksort to perform it's sorting, the algorithm offers n*log(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. That sort I have seen it suggested elsewhere that it uses Merge Sort

Worst Case Performance: O(n^2^) - although in practice this is very rare behaviour.
Best Case Performance: O(n log n)
Average Case Performance: O(n log n)
NOTE: Quick Sorts space complexity is O(log n) where as Merge Sorts is O(n)

=== Merge Sort - O(n log n) (guaranteed) ===
*Basic Idea*: This is a classic divide and conquer algorithm. Recursively halve your array until each item is on its own, then scan the first two items placing them in the correct order, complete this process with the next two items until each single item has been ordered as a pair (ignore odds), then take the first two pairs of sorted lists and scan both to create a order list of 4 items, keep going until the list of back together.

Worst Case Performance: O(n log n)
Best Case Performance: O(n log n)
Average Case Performance: O(n log n)

=== Timsort - O(n log n) ===
*Basic Idea*: Timsort is a hybrid sorting algorithm, derived from merge sort and insertion sort, designed to perform well on many kinds of real-world data. The algorithm finds subsets of the data that are already ordered, and uses the subsets to sort the data more efficiently. This is done by merging an identified subset, called a run, with existing runs until certain criteria are fulfilled.

Although it originated as a search for the Python programming language, as of Java SE 7 Timsort will be used to Array in Java as well.

Worst Case Performance: O(n log n)
Best Case Performance: O(n)
Average Case Performance: O(n log n)

=== Hash Sort - O(n) ===
*Basic Idea*: Maintain an array of buckets of items which is at least 20-25% larger than your list of items (to reduce clashes) and perform the same calculation on each item to return a numerical representation  of that item such that you can index into the array with that.

*Java Specialist Masters Course*
 * Traditionally (before Java 1.4), the HashMap would contain a sparse array holding pointers to the keys
 * The remainder of dividing hash code by the number of buckets in the sparse array would give the offset
 * When there was a clash, the equals() method was used to ascertain uniqueness (having lots of objects with the same hash code would result in a long list to iterate through)
 * It was important to have a prime number hash map size and to have fairly random distribution of hash codes

 * Since Java 1.4 the HashMap uses bit masking to put the keys into buckets (thus the size of HashMap is always a power of 2 [2,4,8,16,32,34,128,256,...] - if you size the HashMap differently (e.g. 101) it will automatically be resized to one of these values
 * A big disadvantage with bit masking is that it is far more sensitive to bit patterns than the remainder approach (which was ditched because it is quite an expensive operation)
 * The bits are then being mixed around with re-hashing

== Searching ==
=== Linear Search - O(n) ===
*Basic Idea*: Just search through the list from the beginning until you find the item you're looking for. With a linear search it tends* not to make much difference if the list is sorted or not (although you could have a very clever sort designed to place the most frequently used items at the front of the list).

Worst Case Performance: n
Best Case Performance: 1
Average Case Performance: n/2

=== Binary Search - O(log n) ===
*Basic Idea*: Particularly applicable to the tree structures discussed above. The tree must already be sorted and balanced if you want to achieve O(log n) guaranteed, remember that this take time and power in the first place.

Worst Case Performance: O(log n)
Best Case Performance: 1
Average Case Performance: ~O(log n)

=== Hash Search - O(1) ===
*Basic Idea*: Index into the list using the hash code you calculate for your item, if there are clashes you might not achieve your constant time target however if you stick to only ever being ~75-80% full then you shouldn't be too far off.

Hashes are not very efficient in terms of space because by definition you need some empty slots.

----

= Unified Modelling Language (UML) =

UML is a simple diagramming style which consists of boxes that represent classes and their relationships.

== Basics ==

Each box representing a class is subdivided into 3 sections, the first contains the class name and the package name (if any), the second part lists the class's variables and the bottom lists its methods.

 * `public` member variables and methods are prefixed with a `+`
 * `protected` member variables and methods are prefixed with a `-`
 * `private` member variables and methods are prefixed with a `#`
 * `abstract` classes and methods are _italicised_
 * `static` elements are <u>underlined</u>
 * Methods and Variables can optionally have their types appended following a colon `:`, similarly parameter type information on methods can also be included

http://thesandbox.googlecode.com/files/Screen%20shot%202013-02-13%20at%2021.24.58.png

== Inheritance ==

Inheritance is represented using a solid line and a hollow triangular arrow:

http://thesandbox.googlecode.com/files/Screen%20shot%202013-02-13%20at%2020.57.48.png

== Interfaces ==

An interface looks much like inheritance, except that the arrow has a dotted line tail, note that the name `<<interface>>` is shown enclosed within double angle brackets:

http://thesandbox.googlecode.com/files/Screen%20shot%202013-02-13%20at%2021.10.12.png

== Composition ==

Much of the time, a useful representation of a class hierarchy must include how objects are contained in other objects. For example, a Company might include one Employee and one Person (perhaps a contractor):

http://thesandbox.googlecode.com/files/Screen%20shot%202013-02-13%20at%2021.15.05.png

The lines between classes show that there can be 0 to 1 instances of Person in Company and 0 to 1 instances of Employee in Company. If there can be many instances of a class inside another, such as the array of Employees then we represent that object composition as a single line with either an * or 0, * on it:

http://thesandbox.googlecode.com/files/Screen%20shot%202013-02-13%20at%2021.21.13.png

----

= Design Patterns =

The [http://www.oodesign.com/ oodesign.com] website goes into detail of many popular design patterns and principles. 

== Singleton Pattern ==

The Singleton Pattern is a Creational Pattern. 

A singleton is simply a class that is instantiated exactly once, typically a system component that is intrinsically unique, such as the window manager or file system. The singleton itself must also provide a single point of access for those who depend on it.

Item 3 of Effective Java 2^nd^ Ed. for this one. The Java Specialists Masters course also details the static Holder approach.

== Observer Pattern ==

The Observer Pattern defines a one-to-many dependency between objects so that when one object changes state, all of its dependencies are notified and updated automatically.

Java provides an inbuilt Observer pattern using the `Observable` class (which you extend as the Object to be observed) and the `Observer` interface which you implement if you want to be notified of changes in an `Observable`. Each `Observer` must be registered with the `Observable` is observes.

== Factory Method Pattern ==

The Factory Pattern (aka Virtual Constructor) is also a Creational Pattern, it defines an interface for creating an object, but let subclasses decide which class to instantiate. The Factory Method lets a class defer instantiations to subclasses.

Example usage in Java would be the `Collection` interface extending the `Iterable` interface...the `LinkedList` class which implements `Collection` is responsible for creating a `LinkedListItr` from it's `Iterator iterator()` method. Note that the `LinkedListItr` implements the `Iterator` interface.

== Facade ==

The intent of the Facade pattern (a Structural Pattern) is to present a simple (unified) interface for interacting with a complex subsystem. 

Examples in Java:
 * The `SwingUtilities` class is a facade and has methods such as `invokeLater()`.
 * The `Executors` class is also considered a facade for thread pool creation.

== Decorator Pattern ==

The Decorator Patten (aka Wrapper or Filter) is a Structural Pattern which allows you to attach additional responsibilities to an object dynamically. Decorator provide a flexible alternative to subclassing for extending functionality.

The Java Collections framework provides us with an example of this pattern, as does Item 16 of Effective Java 2^nd^ Ed., both are quite similar. The Collections example is the `Collections.synchronizedXXX(XXX)` method which wraps the `List`, `Map` or `Set` passed in with a wrapper that synchronises access to the underlying collection.

== Visitor Pattern ==

The intent of the visitor pattern is to allow you to represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.

The visitor pattern defines two interfaces, the first is the _Visitor_ interface, implementations must define and implement a `visit` method accepting every class of object which implements the second interface _Visitable_. The _Visitable_ merely offers an `accept` method which takes a _Visitor_ implementation, the aim in then to invoke the correct overloading of the `visit` method in the _Visitor_ by calling something like visitor.visit(this). You can easily add new visitors which do different things when an object of a specific type is visited, however if you implement a new _Visitable_ class then you need to go back and change your _Visitor_ interface and all of it's implementations. This is pretty difficult to understand without a diagram and some example code, both of which can be found [http://www.oodesign.com/visitor-pattern-customers-report-java-sourcecode.html here].

== Inversion of Control (IoC) & Dependency Injection (DI) ==

The main idea behind _IoC_ is that instead of your application code being completely in control and deciding when to call objects to go out and do the required work you reverse the situation so that another thread decides when and which object/method of your code is called. The best analogy for this idea is the idea of a command like application vs. a GUI built using a GUI framework e.g. Swing...when implementing a GUI framework like Swing all you have to do is supply the user with a button or input mechanism and implement an event handler for that button, the GUI framework then does all the hard work of determining what has happened and then just calls your action listener to do the business. If the GUI framework didn't do all the hard work for you, you'd have to receive every single user action in the same way and then determine yourself which subroutine you should call based on their input (e.g. like a command line application).

The general concept behind _DI_ is called IoC, a class should not configure its dependencies but should be configured from outside ([ http://www.vogella.com/articles/DependencyInjection/article.html from here]), thus when you code is called (by whatever means) it already has all its dependencies configured so is not required to go out and locate them.

One of the most common Dependency Injection frameworks is [http://www.springsource.org/ Spring], although [http://code.google.com/p/google-guice/ Google's Guice] is also very popular. What these frameworks do is collect all the objects your application requires centrally which allows you to build each dependency level in turn. The are five main benefits to _DI_, these are summarised below:

|| *Benefit* || *Description* || *Example* ||
|| Loose coupling || Your code is no longer tightly bound to creating the dependencies it needs. Combined with the technique of coding to interfaces, it can also mean that your code is no longer tightly bound to specific implementations of a dependency. || Instead of your !HollywoodService object needing to create its own !SpreadsheetAgentFinder, it can have it passed in to it. If you’re coding to interfaces, this means that the !HollywoodService can have any type of !AgentFinder passed to it. ||
|| Testability || As an extension to loose coupling, there's a special use case worth mentioning. For the purposes of testing, you can inject a test double as a dependency. || You can inject a stub ticket pricing service that always returns the same price, as opposed to using the 'real' pricing service, which is external and not always available. ||
|| Greater cohesion || Your code is more focused on performing its task as opposed to dealing with loading and configuring dependencies. A side benefit to this is increased readability. || Your DAO (Data Access Object) is focused on executing queries and not on looking up JDBC driver details. ||
|| Reusable components || As an extension to loose coupling, your code can be utilized by a wider range of users who can provide their own specific implementations. || An enterprising software developer could sell you a !LinkedIn agent finder. ||
|| Lighter code || Your code no longer needs to pass dependencies between layers. Dependencies can instead be injected directly at the point they’re required. || Instead of passing down the JDBC driver details from a service class, you can directly inject the driver at the DAO where it’s really needed. ||

=== Evolution ===

The evolution from hard-code classes/objects to classes/objects built using _DI_ can be traced as follows:

 # Hard coding
 # The Factory Method, Abstract Factory or Service Locator Patterns
 # Dependency Injection

See chapter 3 of the Well Grounded Java developer for more information.

If you're still struggling with the concepts the first paragraph of the [http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/beans.html Spring IoC documentation] does a nice job of breaking things down:

   IoC is also known as dependency injection (DI). It is a process whereby objects define their dependencies, that is, the other objects they work with, only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse, hence the name Inversion of Control (IoC), of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes, or a mechanism such as the Service Locator pattern.

----

= Enterprise Integration/Design Patterns =

http://www.eaipatterns.com/index.html

----

= Process Methodologies =

== Scrum (Agile Development) ==

Scrum is an iterative and incremental agile software development method for managing software projects and product or application development. The original [http://www.scrum.org/Scrum-Guides Scrum Guide] is available from the home of Scrum and is written by the developers and formalisers or the process. The are also a number of other related articles which are worth reading:

 * [http://en.wikipedia.org/wiki/Scrum_%28development%29 Scrum (development) on Wikipedia]
 * [http://www.scrum.org/Resources/What-is-Scrum What is Scrum?]
 * [http://www.agilemodeling.com/artifacts/userStory.htm About User Stories]
 * [http://en.wikipedia.org/wiki/Planning_poker Time Estimation & Planning]

== Code Reviews ==

What should you actually look for?

 # Logical bugs
 # Stupid bugs
 # Unreadable code
 # Ugly code that should be refactored

There are may benefits to a code review, primarily in terms of the quality of code because they allow you to spot bugs before the code goes to production. I also like the fact that they prevent knowledge being silo-ed in a single team member, which is particularly beneficial in a large/expanding team or a new project - after all you never when you might be called to fix a problem in another developer's code. The Elastic Leadership blog says that [http://5whys.com/blog/what-should-a-good-code-review-look-and-feel-like.html a good code review] should:
 * Present learning opportunities at every turn, even down to the way each developer works e.g. What was the keyboard shortcut?
 * Increase code quality...obviously
 * Only be 5-15 mins long meaning that you can only cover a small part of the code base, this encourages commits to be modular compete (something which is sought after in agile development as in theory you code should always be ready be release if needs be)
 * Not use tools (like [https://www.atlassian.com/software/crucible/overview Crucible]) to help you because using them misses the point of learning something from someone by interacting with them.

This blog also provides a step-by-step guide which is well worth a read...[http://5whys.com/blog/step-4-start-doing-code-reviews-seriously.html here]. They sum up code reviews as follows:

   Code reviews are nothing short of a magical process of growing people, code quality and confidence at the same time. 

== Code Quality ==

=== Sonar ===

[http://www.sonarsource.org/ Sonar] is an open platform to manage code quality. As such, it covers the 7 axes of code quality:
 * Architecture & Design
 * Duplications
 * Unit Tests
 * Complexity
 * Potential bugs
 * Coding rules
 * Comments

One Sonar plug in which is definitely worth investiating and installing is [http://checkstyle.sourceforge.net/index.html#Related_Tools Checkstyle]

----

= The OSI Application Model =

The [http://en.wikipedia.org/wiki/OSI_model Open Systems Interconnection] (OSI) model is a model used standardise the functions of a communications system in terms of abstraction layers. Similar communication functions are grouped into logical layers. A layer serves the layer above it and is served by the layer below it.

The 7 layers from top (nearest the user) to bottom are:<br>
*Application*<br>
*Presentation*<br>
*Session*<br>
*Transport*<br>
*Network*<br>
*Data Link*<br>
*Physical*

Below the are describe from bottom to top...

== Physical ==
The *Physical Layer* describes the physical properties of the various communications media; as well as the electrical properties and interpreation of the exchanged signals.<br/>
Example: this layer defines the size of the Ethernet coaxial cable, the type of the BNC connector used, and the termination method. e.g. IEEE 802.11

== Data Link ==
The *Data Link Layer* describes the logical organisation of data bits transmitted on a particular medium.<br/>
Example: this layer defines the framing, addressing and checksumming of Ethernet packets. e.g. Point-to-Point Protocol (PPP)

== Network ==
The *Network Layer* describes how a series of exchanges over various data links can deliver data between any two modes in a network.<br>
Example: this layer defines the addressing and routing structure of the Internet. e.g. IP (v4/v6)

== Transport ==
The *Transport Layer* describes the quality and nature of the data delivery.<br>
Example: this layer defines if and how retransmissions will be used to ensure data delivery. e.g. TCP/UDP

== Session ==
The *Session Layer* describes the organisation of data sequences larger than the packets handled by lower layers.<br>
Example: the layer describes how request and reply packets are paired in a remote procedure call. e.g. TSL/SSL

== Presentation ==
The *Presentation Layer* describes the syntax of data being transferred. <br>
Example: this layer describes how floating point numbers can be exchanged between hosts with different math formats. e.g. MIME

== Application ==
The *Application Layer* describes how real work actually gets done.<br>
Example: this layer would implement file system operations. e.g. HTTP, DHCP, NFS

----

= Architectures (32-bit vs. 64-bit) =

A 64-bit computer architecture generally has integer and addressing registers that are 64 bits wide, allowing direct support for 64-bit data types and addresses.

== 64-bit Java ==

For Java specific 64-bit information see the [http://www.oracle.com/technetwork/java/hotspotfaq-138619.html#64bit_description FAQ]

A compiled Java program can run on a 32- or 64-bit Java virtual machine without modification. The lengths and precision of all the built-in types are specified by the standard and are not dependent on the underlying architecture. Java programs that run on a 64-bit Java virtual machine have access to a larger address space (this is the primary advantage), this allows for a much larger Java heap size and an increased maximum number of Java Threads, which is needed for certain kinds of large or long-running applications.

The additional overhead of having native pointers in the system which take up 8 bytes instead of 4 means that a small performance penalty is often observed when porting from 32-bit to 64-bit Java, however the the benefits of being able to address larger amounts of memory might make that it worth it. Any degradation will depend on the amount of pointer accessing your application performs.

=== IMPORTANT ===

*What it is NOT*:  Many Java users and developers assume that a 64-bit implementation means that many of the built-in Java types are doubled in size from 32 to 64.  This is not true.  We did not increase the size of Java integers from 32 to 64 and since Java longs were already 64 bits wide, they didn't need updating.  Array indexes, which are defined in the Java Virtual Machine Specification, are not widened from 32 to 64.  We were extremely careful during the creation of the first 64-bit Java port to insure Java binary and API compatibility so all existing 100% pure Java programs would continue running just as they do under a 32-bit VM.

= Books =

[http://ofps.oreilly.com/titles/9781449323950/index.html Spring Data] - A book covering various Spring related topics including MongoDB, Neo4J & GemFire.

 * [http://flylib.com/category/en/ Fly Lib]

= Blogs =

[http://www.javarevisited.blogspot.co.uk/ Javarevisited]

Blog about Java Program Tutorial Example How to, Unix Linux commands, Interview Questions, FIX Protocol, Tibco RV tutorials, Equities trading system, MySQL

http://ebookfree4all.blogspot.co.uk/

http://books4career.blogspot.co.uk/

[http://5whys.com/ Elastic Leadership - Notes to a Software Team Leader]