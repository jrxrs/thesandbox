#summary A selection of useful resources for various Programming Languages.

<wiki:toc max_depth="2" />

= Java =

== P.I.E. - The Pillars of Object Orientation ==

=== Polymorphism ===

[http://en.wikipedia.org/wiki/Polymorphism_in_object-oriented_programming Wikipedia: Polymorphism]

  * Is the ability of methods to behave differently, based on the object calling it

=== Inheritance ===

[http://en.wikipedia.org/wiki/Inheritance_(computer_science) Wikipedia: Inheritance]

  * In simple words, Inheritance is way to define new a class, using classes which have already been defined

=== Encapsulation ===

[http://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming) Wikipedia: Encapsulation]

  * With Encapsulation you can hide (restrict access) to critical data members in your code , which improves security
  * Encapsualtion combines data and actions together (just like a capsule)

==== Data Abstraction ====

[http://wiki.answers.com/Q/What_is_data_abstraction_in_java Data Abstraction in Java]

  * Abstraction in the process of selecting important data sets for an Object in your software , and leaving out the insignificant ones.
  * Once you have modeled your object using Abstraction , the same set of data could be used in different applications.

== Autoboxing ==

Autoboxing is available as of Java 1.5.0 and introduces the automated handling of primitive Java type to their equivalent Wrapper class. [http://java.sun.com/j2se/1.5.0/docs/guide/language/autoboxing.html Java 1.5.0 Language Guilde]

== Imports & Performace ==

Did some research and it seems that conventional wisdom suggests that using imports with the wild card character, of the form:
{{{
import javax.swing.*;
}}}
does not impact runtime performance. There is however a valid case for specifying exactly the classes you wish to import as detailed in [http://www.javafaq.nu/java-article914.html this article].

== Mutable & Immutable Objects ==

[http://www.javaranch.com/journal/2003/04/immutable.htm Java Ranch - Mutable and Immutable Objects]

== Generics ==

[http://onjava.com/onjava/excerpt/javaian5_chap04/index1.html Writing Generic Types & Methods]

== Checked & Unchecked Exceptions ==

[http://tutorials.jenkov.com/java-exception-handling/checked-or-unchecked-exceptions.html Java Exception Handling - Checked or Unchecked Exceptions]

== Challenging Java Questions ==

[http://robaustin.wikidot.com/50-java-interview-questions Java Interview Questions]

== Threading & Lock Contention ==

[http://www.thinkingparallel.com/2007/07/31/10-ways-to-reduce-lock-contention-in-threaded-programs/ 10 Ways to Reduce Lock Contention in Threaded Programs]

= Java EE =

[http://docs.oracle.com/javaee/6/tutorial/doc/docinfo.html Jave EE 6 Tutorial]

= XML =

== SAX & DOM ==

SAX - Event Driven, stack based parsing, akin to shift-reduce mechanism employed by bottom-up parsers. [http://en.wikipedia.org/wiki/Simple_API_for_XML Wikipedia]

DOM - Tree Walking [http://en.wikipedia.org/wiki/Document_Object_Model Wikipedia]

[http://onjava.com/onjava/2002/06/26/xml.html SAX & DOM, the Basics]

[http://www.informit.com/library/library.aspx?b=STY_XML_21days Teach Yourself XML in 21 Days]

= Data Structures & Algorithms =

[http://so-i-think-i-created-my-first-online-project.googlecode.com/files/Data%20Structures%20and%20Algorithms%20in%20Java%20Fourth%20Edition.pdf?bcsi_scan_4c5c01dba4894524=0&bcsi_scan_filename=Data%20Structures%20and%20Algorithms%20in%20Java%20Fourth%20Edition.pdf Data Structures & Algorithms in Java (4th Edition)]

== Trees ==

=== Depth ===
*Formal Definition:* Let _v_ be a node of a tree _T_. The depth of _v_ is the number of ancestors of _v_, excluding _v_ itself. If _v_ is the root, then the depth of _v_ is 0.
*Informal Definition:* How deep down the tree is the node you're concerned with?

=== Height ===
*Formal Definition:* The height of a node _v_ in a tree _T_ is defined recursively:<br><li>If _v_ is an external node, then the height of _v_ is 0
<br><li>Otherwise, the height of _v_ is one plus the maximum height of a child of _v_.<br>
*Informal Definition:* So basically how far is _v_ away from it's further descendant which is a leaf (external node). 

Adapted from [http://en.wikipedia.org/wiki/Red_black_tree Red-Black Tree]: Both Red-Black tree ([http://www.ece.uc.edu/~franco/C321/html/RedBlack/redblack.html demo]) and AVL trees ([http://www.strille.net/works/media_technology_projects/avl-tree_2001/ demo]) support O(log n) search, insertion, and removal. AVLs are more rigidly balanced than red–black trees, leading to slower insertion and removal but faster retrieval. This makes AVLs attractive for data structures that may be built once and loaded without reconstruction, such as language dictionaries (or program dictionaries, such as the opcodes of an assembler or interpreter).

2-4 Trees ([http://www.cs.unm.edu/~rlpm/499/ttft.html demo]) are fundamental to understanding red-black trees because the insertion and deletion operations on 2-4 trees are also equivalent to colour-flipping and rotations in red–black trees, despite this 2-4 trees are seldom used in practice. Try walking through the [http://en.wikipedia.org/wiki/2-4_tree#Example example] from wikipedia of a 2-3-4 tree insertion.

*Differentiating Red-Black Trees*

Although AVL trees and (2,4) trees have a number of nice properties, there are some dictionary applications for which they are not well suited. For instance, AVL trees may require many restructure operations (rotations) to be performed after a removal, and (2,4) trees may require many fusing or split operations to be performed after either an insertion or removal. The red-black tree data structure does not have these drawbacks, however, as it requires that only O(1) structural changes be made after an update in order to stay balanced.

= Complexity (Big O) =

[http://pages.cs.wisc.edu/~vernon/cs367/notes/3.COMPLEXITY.html Complexity & Big-O Notation]
[http://stackoverflow.com/questions/2307283/what-does-olog-n-mean-exactly Good Explanation of O(log n) from Stackoverflow]

= Maths =

[http://oakroadsystems.com/math/loglaws.htm Logarithms]